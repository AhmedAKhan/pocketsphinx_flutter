// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/pocketsphinx_flutter.h`.
///
/// Regenerate bindings with `dart run ffigen`.
///
class PocketsphinxFlutterBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  PocketsphinxFlutterBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  PocketsphinxFlutterBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// Initialize the recognizer with HMM, Dictionary, and optional Keyword list.
  /// Returns a pointer to the ps_decoder_t object or NULL on failure.
  ffi.Pointer<ps_decoder_t> initialize_recognizer(
    ffi.Pointer<ffi.Char> hmm_path,
    ffi.Pointer<ffi.Char> dict_path,
    ffi.Pointer<ffi.Char> kws_path,
  ) {
    return _initialize_recognizer(hmm_path, dict_path, kws_path);
  }

  late final _initialize_recognizerPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ps_decoder_t> Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
          )
        >
      >('initialize_recognizer');
  late final _initialize_recognizer = _initialize_recognizerPtr
      .asFunction<
        ffi.Pointer<ps_decoder_t> Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
        )
      >();

  /// Free the recognizer resources.
  void free_recognizer(ffi.Pointer<ps_decoder_t> ps) {
    return _free_recognizer(ps);
  }

  late final _free_recognizerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ps_decoder_t>)>>(
        'free_recognizer',
      );
  late final _free_recognizer = _free_recognizerPtr
      .asFunction<void Function(ffi.Pointer<ps_decoder_t>)>();

  /// Start processing an utterance.
  int start_processing(ffi.Pointer<ps_decoder_t> ps) {
    return _start_processing(ps);
  }

  late final _start_processingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ps_decoder_t>)>>(
        'start_processing',
      );
  late final _start_processing = _start_processingPtr
      .asFunction<int Function(ffi.Pointer<ps_decoder_t>)>();

  /// Process a chunk of audio data.
  /// data: pointer to 16-bit PCM audio samples.
  /// n_samples: number of samples (not bytes).
  int process_audio_chunk(
    ffi.Pointer<ps_decoder_t> ps,
    ffi.Pointer<ffi.Int16> data,
    int n_samples,
  ) {
    return _process_audio_chunk(ps, data, n_samples);
  }

  late final _process_audio_chunkPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<ps_decoder_t>,
            ffi.Pointer<ffi.Int16>,
            ffi.Int,
          )
        >
      >('process_audio_chunk');
  late final _process_audio_chunk = _process_audio_chunkPtr
      .asFunction<
        int Function(ffi.Pointer<ps_decoder_t>, ffi.Pointer<ffi.Int16>, int)
      >();

  /// End processing an utterance.
  int stop_processing(ffi.Pointer<ps_decoder_t> ps) {
    return _stop_processing(ps);
  }

  late final _stop_processingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ps_decoder_t>)>>(
        'stop_processing',
      );
  late final _stop_processing = _stop_processingPtr
      .asFunction<int Function(ffi.Pointer<ps_decoder_t>)>();

  /// Get the hypothesis string.
  /// Returns a string owned by the decoder (do not free).
  ffi.Pointer<ffi.Char> get_hypothesis(ffi.Pointer<ps_decoder_t> ps) {
    return _get_hypothesis(ps);
  }

  late final _get_hypothesisPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ps_decoder_t>)
        >
      >('get_hypothesis');
  late final _get_hypothesis = _get_hypothesisPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ps_decoder_t>)>();
}

/// @struct ps_decoder_t
/// @brief Speech recognizer object.
typedef ps_decoder_t = ps_decoder_s;

/// Forward declaration needed to avoid circular includes
final class ps_decoder_s extends ffi.Opaque {}
